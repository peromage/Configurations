# interactive mode initialization script
# prevent from being loaded twice
if [ -z "$_INIT_SH_LOADED" ]; then
    _INIT_SH_LOADED=1
else
    return
fi

# if in non-interactive mode then exit
case "$-" in
    *i*) ;;
    *) return
esac

# ============== functions ===========================
function _bash_prompt() {
    # backup last exit code
    ret=$?

    # give word some colors
    # usage: gssc <word> <color_code>
    function gssc() {
        echo "\[\e[${2}\]${1}\[\e[0m\]"
    }

    # prompt style generator 1
    # usage: style1 <symbol> <color_code>
    function style1() {
        # login
        login=$(gssc "\u@\h" $2)
        # path
        currpath=$(gssc "\w" "33m")
        # last exit status
        face=$([ "$ret" -eq "0" ] && echo "$(gssc ":)" "32m")" || echo "$(gssc ":(" "31m")")

        #override prompt
        PS1="${login}:${currpath} ${face} ${1} "
    }

    case "$UID" in
        0) style1 "#" "31m" ;;
        *) style1 "\$" "32m" ;;
    esac
}

function colortest() {
    width=7
    word="gYm"

    # print columns with background colors
    function pcbg() {
        printf "%${width}s " ${1:3}
        printf "$1%${width}s " $2
        for i in {40..47}; do
            printf "$1\e[${i}m%${width}s\e[0m " $2
        done
        printf "\n"
    }

    # header
    printf "%${width}s %${width}s " "code" "m"
    for i in {40..47}; do
        printf "%${width}s " "${i}m"
    done
    printf "\n" 
    # print row by row
    pcbg "\e[0m" $word
    pcbg "\e[1m" $word
    for j in {30..37}; do
         pcbg "\e[${j}m" $word
         pcbg "\e[1;${j}m" $word
    done
}
# =============== end functions ======================

if [ -n "$BASH_VERSION" ]; then
    export PROMPT_COMMAND=_bash_prompt
#elif [ -n "$ZSH_VERSION"]; then

fi

